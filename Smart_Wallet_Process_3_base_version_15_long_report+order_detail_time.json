{
  "name": "Smart_Wallet_Process_3_base_version_15_long_report+order detail time",
  "nodes": [
    {
      "parameters": {},
      "id": "e09d9223-fc1f-490b-9e3e-b6a66ed10e8b",
      "name": "Cron (every 2m)",
      "type": "n8n-nodes-base.cron",
      "typeVersion": 1,
      "position": [
        -1776,
        496
      ],
      "alwaysOutputData": true,
      "options": {
        "interval": {
          "minutes": 2
        }
      },
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "language": "JavaScript",
        "jsCode": "/* Scenario Configs — edit here without touching logic */
const scenarios = [
  { name:'Optimistic', params:{ capitalUSD:300, takerFee:0.0002, slippage:0.0003, borrowDaily:0.00010, targetLTV:0.70, minProfitDailyPct:0.0002 }},
  { name:'Base',       params:{ capitalUSD:200, takerFee:0.0004, slippage:0.0005, borrowDaily:0.00020, targetLTV:0.60, minProfitDailyPct:0.0005 }},
  { name:'Pessimistic',params:{ capitalUSD:200, takerFee:0.0006, slippage:0.0007, borrowDaily:0.00035, targetLTV:0.50, minProfitDailyPct:0.0008 }}
];

/* Freshness policy for trading universe (fallback if cadence can't be inferred) */
const freshness = {
  maxFundingAgeMin: 90,   // default tolerance if cadence inference fails
  minPriceUSD: 0.2,       // ignore assets priced below this
  allowZeroFunding: false // if false, zero funding excluded from the trade universe
};

/* Auto-scanner grid */
const scannerGrid = {
  capitalUSD:        [200, 300, 500],
  takerFee:          [0.0003, 0.0004, 0.0005],
  slippage:          [0.0004, 0.0005, 0.0007],
  borrowDaily:       [0.00015, 0.00020, 0.00030],
  targetLTV:         [0.50, 0.60, 0.70],
  minProfitDailyPct: [0.0002, 0.0003, 0.0005, 0.0008, 0.0012]
};

return [{ json:{ scenarios, scannerGrid, freshness } }];"
      },
      "id": "1eaa5819-80c5-492a-a342-b0967e9eeabe",
      "name": "Scenario Configs",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [
        -1584,
        704
      ],
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "language": "JavaScript",
        "jsCode": "/* Assets supported by Coinbase spot (USD) + Kraken Futures perp (USD) */
/* For quick control, set enabled:false to exclude an asset */
const assets = [
  {asset:'BTC',  cb:'BTC-USD',  kr:'PI_XBTUSD',  enabled:true},
  {asset:'ETH',  cb:'ETH-USD',  kr:'PI_ETHUSD',  enabled:true},
  {asset:'SOL',  cb:'SOL-USD',  kr:'PF_SOLUSD',  enabled:true},
  {asset:'XRP',  cb:'XRP-USD',  kr:'PF_XRPUSD',  enabled:true},
  {asset:'ADA',  cb:'ADA-USD',  kr:'PF_ADAUSD',  enabled:true},
  {asset:'DOGE', cb:'DOGE-USD', kr:'PF_DOGEUSD', enabled:true},
  {asset:'DOT',  cb:'DOT-USD',  kr:'PF_DOTUSD',  enabled:true},
  {asset:'LINK', cb:'LINK-USD', kr:'PF_LINKUSD', enabled:true},
  {asset:'LTC',  cb:'LTC-USD',  kr:'PI_LTCUSD',  enabled:true},
  {asset:'BCH',  cb:'BCH-USD',  kr:'PI_BCHUSD',  enabled:true},
  {asset:'AVAX', cb:'AVAX-USD', kr:'PF_AVAXUSD', enabled:true},
  {asset:'MATIC',cb:'MATIC-USD',kr:'PF_MATICUSD',enabled:true},
  {asset:'ATOM', cb:'ATOM-USD', kr:'PF_ATOMUSD', enabled:true},
  {asset:'XLM',  cb:'XLM-USD',  kr:'PF_XLMUSD',  enabled:true},
  {asset:'UNI',  cb:'UNI-USD',  kr:'PF_UNIUSD',  enabled:true},
  {asset:'ETC',  cb:'ETC-USD',  kr:'PF_ETCUSD',  enabled:true},
  {asset:'FIL',  cb:'FIL-USD',  kr:'PF_FILUSD',  enabled:true},
  {asset:'ALGO', cb:'ALGO-USD', kr:'PF_ALGOUSD', enabled:true},
  {asset:'AAVE', cb:'AAVE-USD', kr:'PF_AAVEUSD', enabled:true},
  {asset:'NEAR', cb:'NEAR-USD', kr:'PF_NEARUSD', enabled:true}
].filter(a=>a.enabled);
return assets.map(a => ({ json: a }));"
      },
      "id": "dff9cad2-71f9-46b7-95f0-db7c5ccbb4d9",
      "name": "Assets Config (20 both-supported)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [
        -1600,
        496
      ]
    },
    {
      "parameters": {
        "url": "={{ 'https://api.exchange.coinbase.com/products/' + $json.cb + '/ticker' }}",
        "options": {
          "response": {},
          "timeout": 8000
        }
      },
      "id": "54032394-05bf-4d04-a809-9c17a9809466",
      "name": "CB — Fetch Price (per asset)",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        -1392,
        416
      ],
      "alwaysOutputData": true,
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "url": "={{ 'https://futures.kraken.com/derivatives/api/v3/historical-funding-rates?symbol=' + $json.kr }}",
        "options": {
          "response": {},
          "timeout": 8000
        }
      },
      "id": "0725c8ee-4214-41a1-aeca-83383cd5ec21",
      "name": "KR — Funding (per asset)",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        -1392,
        576
      ],
      "alwaysOutputData": true,
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "mode": "wait",
        "options": {}
      },
      "id": "f5739b47-3bb1-496a-9e51-a126e14659d2",
      "name": "Merge CB (wait)",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 2,
      "position": [
        -1200,
        416
      ],
      "alwaysOutputData": true,
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "mode": "wait",
        "options": {}
      },
      "id": "7a44c910-a02d-45b7-afdf-6af1ee10c8ea",
      "name": "Merge KR (wait)",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 2,
      "position": [
        -1200,
        576
      ],
      "alwaysOutputData": true,
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "mode": "wait",
        "options": {}
      },
      "id": "deb8e057-a87f-43b4-b26e-aad644c88101",
      "name": "Barrier CB+KR",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 2,
      "position": [
        -1008,
        496
      ],
      "alwaysOutputData": true,
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "language": "JavaScript",
        "jsCode": "/* Assemble snapshot from CB+KR; standardize Kraken timestamp to ms */
const list = $items('Assets Config (20 both-supported)').map(i=>i.json);
const cbAll = $('CB — Fetch Price (per asset)').all();
const krAll = $('KR — Funding (per asset)').all();
const toNum = v => { const n = +v; return Number.isFinite(n) ? n : null };
const pick = (o,keys)=>{ for(const k of keys){ const v = toNum(o?.[k]); if(v!==null) return v;} return null };
const toMs = t=>{ if(!t&&t!==0) return null; const n=+t; if(Number.isFinite(n)) return n<1e12? n*1000 : n; const d=Date.parse(t); return Number.isFinite(d)? d : null; };
function parseCB(it){ const j = it?.json ?? it; return pick(j||{}, ['price','last','ask','bid']); }
function parseKR(it){ const j = it?.json ?? it; const arr = j?.rates || j?.funding_rates || j?.data || j?.result?.rates || []; if (Array.isArray(arr) && arr.length>0){ const last = arr[arr.length-1]; return last; } return null; }
const priceMap = {}, priceSrc = {}, f8hMap = {}, krTsMap = {}, errors = {};
for(let i=0;i<list.length;i++){
  const meta = list[i]; const cbResp = cbAll[i]; const krResp = krAll[i];
  // CB price
  let p=null, reasonCB=null; try { p = parseCB(cbResp); if(p===null) reasonCB='cb_no_price'; } catch(e){ reasonCB='cb_parse_err'; }
  const scCB = cbResp?.json?.statusCode || cbResp?.statusCode; if (scCB && scCB !== 200) reasonCB = `cb_http_${scCB}`;
  if (p!==null) { priceMap[meta.asset]=+p; priceSrc[meta.asset]='CB'; } else { priceMap[meta.asset]=0; priceSrc[meta.asset]='CB:miss'; if(reasonCB) errors[meta.asset]=(errors[meta.asset]?errors[meta.asset]+';':'')+reasonCB; }
  // KR funding
  let last=null, reasonKR=null; try { last = parseKR(krResp); if(last===null) reasonKR='kr_no_rates'; } catch(e){ reasonKR='kr_parse_err'; }
  const scKR = krResp?.json?.statusCode || krResp?.statusCode; if (scKR && scKR !== 200) reasonKR = `kr_http_${scKR}`;
  const rate = pick(last||{}, ['rate','fundingRate','funding_rate','relativeFundingRate','value']);
  const tsMs = toMs((last && (last.time||last.timestamp||last.ts||last.date)) || null);
  if (toNum(rate)!==null) { f8hMap[meta.asset]=toNum(rate); krTsMap[meta.asset]=tsMs; }
  else { f8hMap[meta.asset]=NaN; krTsMap[meta.asset]=tsMs; if(reasonKR) errors[meta.asset]=(errors[meta.asset]?errors[meta.asset]+';':'')+reasonKR; }
}
return [{ json: { timestamp: new Date().toISOString(), final: priceMap, funding8h: f8hMap, krTs: krTsMap, whichSource: priceSrc, errors } }];"
      },
      "id": "39928903-e7ac-434b-baa1-f60a1eb595d3",
      "name": "Assemble Snapshot",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [
        -832,
        496
      ]
    },
    {
      "parameters": {
        "language": "JavaScript",
        "jsCode": "/* Multi-scenario + Auto Scanner + Fresh-only + Exchange-time validity */
const s=$json; const wf=$workflow.name; const ts=s.timestamp;
const final=s.final||{}; const f8h=s.funding8h||{}; const errs=s.errors||{}; const krTs=s.krTs||{};
const pct=v=> (v*100).toFixed(3)+'%'; const N=v=>{const n=+v;return Number.isFinite(n)?n:0};
const assets = Object.keys(final);
// Safe Scenario Configs
let cfg={}; try { const ref=$('Scenario Configs'); if(ref&&typeof ref.first==='function'){ const it=ref.first(); if(it&&it.json) cfg=it.json; } } catch(_) {}
const scenarios = Array.isArray(cfg.scenarios)&&cfg.scenarios.length?cfg.scenarios:[
  {name:'Optimistic', params:{capitalUSD:300, takerFee:0.0002, slippage:0.0003, borrowDaily:0.00010, targetLTV:0.70, minProfitDailyPct:0.0002}},
  {name:'Base',       params:{capitalUSD:200, takerFee:0.0004, slippage:0.0005, borrowDaily:0.00020, targetLTV:0.60, minProfitDailyPct:0.0005}},
  {name:'Pessimistic',params:{capitalUSD:200, takerFee:0.0006, slippage:0.0007, borrowDaily:0.00035, targetLTV:0.50, minProfitDailyPct:0.0008}}
];
const grid = cfg.scannerGrid || {capitalUSD:[200,300,500],takerFee:[0.0003,0.0004,0.0005],slippage:[0.0004,0.0005,0.0007],borrowDaily:[0.00015,0.00020,0.00030],targetLTV:[0.50,0.60,0.70],minProfitDailyPct:[0.0002,0.0003,0.0005,0.0008,0.0012]};
const freshCfg = cfg.freshness || { maxFundingAgeMin: 90, minPriceUSD: 0.2, allowZeroFunding: false };

// ---- Freshness (Adaptive cadence from exchange) ----
const now = Date.now();
const agesMin = {};
function ageMin(asset){ const t=+krTs[asset]; const a = Number.isFinite(t) ? Math.max(0,(now - t)/60000) : Infinity; agesMin[asset]=a; return a; }
const allAges = assets.map(a=>ageMin(a)).filter(x=>Number.isFinite(x) && x<2000).sort((a,b)=>a-b);
function median(arr){ return arr.length ? arr[Math.floor(arr.length/2)] : NaN; }
const medAge = median(allAges);
let inferredCadenceMin = freshCfg.maxFundingAgeMin; // fallback
if (Number.isFinite(medAge)){
  if (medAge >= 40 && medAge <= 80)        inferredCadenceMin = 60;   // ~hourly
  else if (medAge >= 180 && medAge <= 300) inferredCadenceMin = 240;  // ~4h
  else if (medAge >= 360 && medAge <= 540) inferredCadenceMin = 480;  // ~8h
}
const effectiveFreshWin = Math.max(freshCfg.maxFundingAgeMin, Math.round(inferredCadenceMin*1.5));
function validUntilIso(asset){ const t=+krTs[asset]; if(!Number.isFinite(t)) return null; return new Date(t + inferredCadenceMin*60000).toISOString(); }
function remainingMin(asset){ const a=agesMin[asset]; return Number.isFinite(a) ? Math.max(0, inferredCadenceMin - a) : 0; }
function fmtRemain(min){ const m=Math.max(0,Math.floor(min)); const h=Math.floor(m/60); const mm=m%60; return (h>0?`${h}h `:'')+`${mm}m`; }

function isFresh(asset){
  const a = agesMin[asset];
  const priceOk  = Number.isFinite(final[asset]) && final[asset] >= freshCfg.minPriceUSD;
  const rateOk   = Number.isFinite(f8h[asset]) && (freshCfg.allowZeroFunding ? true : f8h[asset] !== 0);
  return a <= effectiveFreshWin && priceOk && rateOk;
}
const tradeAssets = assets.filter(isFresh);
const staleAssets = assets.filter(a=>!isFresh(a)).map(a=>({asset:a, age:agesMin[a], price:final[a], r8:f8h[a]}));

function analyzeAsset(asset, P){
  const price=N(final[asset]); const fDaily=N(f8h[asset])*3; const fAbs=Math.abs(fDaily); const fees=P.takerFee+P.slippage;
  const action=fDaily>=0?'Short perp (KR) + Long spot (CB)':'Long perp (KR) + Short spot (CB)';
  const edgePerNotional=fAbs-fees; const canBorrow=(edgePerNotional-P.borrowDaily)>=P.minProfitDailyPct;
  let borrowed=0, notional=P.capitalUSD; if(canBorrow){ borrowed=Math.floor((P.capitalUSD*(P.targetLTV/(1-P.targetLTV)))*100)/100; notional=P.capitalUSD+borrowed; }
  const estDaily=(fAbs-fees)*notional-(canBorrow?P.borrowDaily*borrowed:0);
  let label='VERY LOW'; if(fAbs>=0.0008)label='HIGH'; else if(fAbs>=0.0003)label='MODERATE'; else if(fAbs>=0.0001)label='LOW';
  const qty=price?notional/price:0;
  const age=+agesMin[asset]; const validUntil=validUntilIso(asset); const rem=remainingMin(asset);
  return {asset, spotPrice:price, funding8h:N(f8h[asset]), fundingDaily:fDaily, fundingDailyAbs:fAbs, action, label,
          params:P, capital:P.capitalUSD, borrowed, notional, qty, estDaily, profitable: estDaily>0,
          krAgeMin:+age.toFixed(2), fresh:isFresh(asset), validUntil, remainMin:+rem.toFixed(1)};
}

// Scenario runs (FRESH universe)
const scenarioResults=[]; let globalScenarioBest=null;
for (const sc of scenarios){
  const rows=tradeAssets.map(a=>analyzeAsset(a, sc.params)).sort((a,b)=>b.estDaily-a.estDaily);
  const topGood=rows.filter(r=>r.profitable); const topBad=rows.filter(r=>!r.profitable).slice(0,10);
  scenarioResults.push({name:sc.name, params:sc.params, rows, topGood, topBad});
  if(topGood.length){ const best=topGood[0]; if(!globalScenarioBest || best.estDaily>globalScenarioBest.estDaily) globalScenarioBest={scenario:sc.name, ...best}; }
}

// Auto scanner (FRESH universe)
function* combos(G){ for (const capitalUSD of G.capitalUSD) for (const takerFee of G.takerFee) for (const slippage of G.slippage) for (const borrowDaily of G.borrowDaily) for (const targetLTV of G.targetLTV) for (const minProfitDailyPct of G.minProfitDailyPct) yield {capitalUSD,takerFee,slippage,borrowDaily,targetLTV,minProfitDailyPct}; }
let scanBest=null; const scanTop=[];
for (const P of combos(grid)){
  const rows=tradeAssets.map(a=>analyzeAsset(a,P)).sort((a,b)=>b.estDaily-a.estDaily);
  const best=rows.find(r=>r.profitable);
  if(best){ const rec={ scenario:'ScannerBest', asset:best.asset, action:best.action, estDaily:best.estDaily, fundingDailyAbs:best.fundingDailyAbs, params:P, notional:best.notional, validUntil: best.validUntil, krAgeMin: best.krAgeMin, remainMin: best.remainMin };
    if(!scanBest || rec.estDaily>scanBest.estDaily) scanBest=rec; scanTop.push(rec);
  }
}
scanTop.sort((a,b)=>b.estDaily-a.estDaily); const scanTop3=scanTop.slice(0,3);

// --- Data Health (includes cadence) ---
const cbAll = $('CB — Fetch Price (per asset)').all(); const krAll = $('KR — Funding (per asset)').all();
const okCB = cbAll.filter(x=>{const j=x.json||x; const v=+(j.price||j.last||j.ask||j.bid); return Number.isFinite(v) && v>0;});
const okKR = krAll.filter(x=>{const j=x.json||x; const arr=j.rates||j.funding_rates||j.data||j.result?.rates||[]; if(!Array.isArray(arr)||!arr.length) return false; const last=arr[arr.length-1]; const r=+(last.rate||last.fundingRate||last.funding_rate||last.relativeFundingRate||last.value); return Number.isFinite(r);});
const prices = assets.map(a=>+final[a]).filter(x=>Number.isFinite(x)&&x>0).sort((a,b)=>a-b);
const frates = assets.map(a=>+f8h[a]).filter(x=>Number.isFinite(x)).sort((a,b)=>a-b);
const agesAll = assets.map(a=>agesMin[a]).filter(x=>x!==undefined && x!==null && Number.isFinite(x)).sort((a,b)=>a-b);
const q = (arr,p)=> arr.length? arr[Math.min(arr.length-1, Math.max(0, Math.floor(p*(arr.length-1))))] : null;
const healthLines = [
  '<b>DSFAB — Data Health</b>',
  `Assets: ${assets.length} | CB ok: ${okCB.length}/${cbAll.length} | KR ok: ${okKR.length}/${krAll.length}`,
  `Cadence inferred: ~${inferredCadenceMin}m | Effective fresh window: ${effectiveFreshWin}m`,
  `Fresh policy → minPrice: $${freshCfg.minPriceUSD} | allowZero: ${!!freshCfg.allowZeroFunding}`,
  `Trade universe (fresh): ${tradeAssets.length}/${assets.length}`,
  `Prices range: ${prices.length?('$'+prices[0].toFixed(2)+' .. $'+prices[prices.length-1].toFixed(2)):'n/a'}`,
  `Funding abs (8h→daily*3) | min: ${frates.length?(Math.abs(frates[0]*3)*100).toFixed(3)+'%':'n/a'} | med: ${frates.length?(Math.abs(q(frates,0.5)*3)*100).toFixed(3)+'%':'n/a'} | max: ${frates.length?(Math.abs(frates[frates.length-1]*3)*100).toFixed(3)+'%':'n/a'}`,
  `KR last age (min) | min: ${agesAll.length?agesAll[0].toFixed(1):'n/a'} | med: ${agesAll.length?q(agesAll,0.5).toFixed(1):'n/a'} | max: ${agesAll.length?agesAll[agesAll.length-1].toFixed(1):'n/a'}`
];
if (staleAssets.length){ const topStale = staleAssets.sort((a,b)=>b.age-a.age).slice(0,8).map(x=>`${x.asset}(${Number.isFinite(x.age)?x.age.toFixed(1)+'m':'n/a'})`); healthLines.push('Stale/Filtered: '+topStale.join(', ')+(staleAssets.length>8?' …':'')); }
if (Object.keys(errs).length){ healthLines.push(`Errors: ${Object.entries(errs).map(([a,e])=>a+'('+e+')').join(', ')}`); }
// Full table (prices & funding & age)
function pad(s,n){ s=String(s); return s.length<n? s+' '.repeat(n-s.length) : s.slice(0,n); }
const header = pad('ASSET',6)+' '+pad('PRICE',12)+' '+pad('F8H',12)+' '+pad('DAILY%',8)+' '+pad('AGEm',6)+' SRC';
const rowsTbl=[header, ''.padEnd(header.length,'-')];
for (const a of assets){ const p=Number.isFinite(final[a])?final[a]:0; const r8=Number.isFinite(f8h[a])?f8h[a]:NaN; const dailyPct=Number.isFinite(r8)?(Math.abs(r8*3)*100).toFixed(3)+'%':'n/a'; const age=agesMin[a]; rowsTbl.push(pad(a,6)+' '+pad(p?('$'+p.toFixed(4)):'n/a',12)+' '+pad(Number.isFinite(r8)?r8.toExponential(3):'n/a',12)+' '+pad(dailyPct,8)+' '+pad(Number.isFinite(age)?age.toFixed(1):'n/a',6)+' '+(s.whichSource?.[a]||'-')); }
const healthMsg = healthLines.join('\n');
const healthPrices = '<b>DSFAB — Data Health (Prices)</b>\n<pre>'+rowsTbl.join('\n')+'</pre>';

// Insight report
const lines=[`<b>DSFAB — Insight (Fresh-Only + Auto-Scanner)</b>`, `Workflow: ${wf}`, `Time: ${ts}`, `Fresh universe: ${tradeAssets.length}/${assets.length} (cadence≈${inferredCadenceMin}m, window=${effectiveFreshWin}m)`, ''];
for (const R of scenarioResults){ const P=R.params; lines.push(`🔎 <b>${R.name}</b>  | cap=$${P.capitalUSD} | fee=${(P.takerFee*100).toFixed(2)}% | slip=${(P.slippage*100).toFixed(2)}% | borrow=${(P.borrowDaily*100).toFixed(2)}%/day | LTV=${(P.targetLTV*100).toFixed(0)}% | min=${(P.minProfitDailyPct*100).toFixed(2)}%/day`);
  if (R.topGood.length){ lines.push('✅ <u>Profitable (candidates)</u>'); for (const r of R.topGood.slice(0,6)){ lines.push(`• <b>${r.asset}</b> | ${pct(r.fundingDailyAbs)} | estDaily=$${r.estDaily.toFixed(2)} | age=${r.krAgeMin.toFixed(1)}m | remain≈ ${fmtRemain(r.remainMin)} | ${r.label} | ${r.action}`);} } else { lines.push('✅ Profitable: none'); }
  if (R.topBad.length){ lines.push('❌ <u>Weak / Not profitable</u>'); for (const r of R.topBad){ lines.push(`• ${r.asset} | ${pct(r.fundingDailyAbs)} | estDaily=$${r.estDaily.toFixed(2)} | age=${r.krAgeMin.toFixed(1)}m | ${r.label}`);} }
  lines.push('');
}
lines.push('🧭 <b>Auto-Scanner (best combos)</b>');
if (scanTop3.length){ let rank=1; for (const b of scanTop3){ const P=b.params; const edgePct=(b.fundingDailyAbs*100 - (P.takerFee+P.slippage)*100).toFixed(2); lines.push(`• <b>#${rank}</b> ${b.asset} | edge≈ ${edgePct}%/day | estDaily=$${b.estDaily.toFixed(2)} | notional $${b.notional.toFixed(0)} | remain≈ ${fmtRemain(b.remainMin)} | VALID UNTIL: ${b.validUntil || 'n/a'} | ${b.action}`); rank++; } } else { lines.push('• No profitable combination found on this scan'); }

// Alerts (with exchange-time TTL)
let alert=null;
if (scanBest){ const P=scanBest.params; const edgePct=(scanBest.fundingDailyAbs*100 - (P.takerFee+P.slippage)*100).toFixed(2); const remTxt=fmtRemain(scanBest.remainMin); const validUntil = scanBest.validUntil || 'n/a'; alert = `✅ DSFAB PICK (Auto-Scanner, Fresh)\n${scanBest.asset} — ${scanBest.action}\nedge≈ ${edgePct}%/day\nnotional $${scanBest.notional.toFixed(0)} | estDaily $${scanBest.estDaily.toFixed(2)}\nVALID UNTIL: ${validUntil}\nRemaining ≈ ${remTxt}`; }
else if (globalScenarioBest){ const P=globalScenarioBest.params; const fees=P.takerFee+P.slippage; const edgePct=(globalScenarioBest.fundingDailyAbs*100 - fees*100).toFixed(2); const remTxt=fmtRemain(globalScenarioBest.remainMin||0); alert = `✅ DSFAB PICK (Best Scenario, Fresh)\nScenario: ${globalScenarioBest.scenario}\n${globalScenarioBest.asset} — ${globalScenarioBest.action}\nedge≈ ${edgePct}%/day\nnotional $${globalScenarioBest.notional.toFixed(0)} | estDaily $${globalScenarioBest.estDaily.toFixed(2)}\nRemaining ≈ ${remTxt}`; }

// Rows for Sheets (with age/fresh/validUntil/remain)
const allRows=[];
for (const R of scenarioResults){ for (const x of R.rows){ allRows.push({ timestamp:ts, scenario:R.name, asset:x.asset, spotPrice:x.spotPrice, funding8h:x.funding8h, fundingDailyPct:+(x.fundingDailyAbs*100).toFixed(6), action:x.action, capital:x.capital, borrowed:x.borrowed, notional:x.notional, estDaily:+x.estDaily.toFixed(4), label:x.label, profitable: !!x.profitable, "params.takerFee":x.params.takerFee, "params.slippage":x.params.slippage, "params.borrowDaily":x.params.borrowDaily, "params.targetLTV":x.params.targetLTV, "params.minProfitDailyPct":x.params.minProfitDailyPct, krAgeMin: x.krAgeMin, fresh: !!x.fresh, validUntil: x.validUntil, remainMin: x.remainMin }); } }
for (const b of scanTop3){ const P=b.params; allRows.push({ timestamp:ts, scenario:'ScannerBest', asset:b.asset, spotPrice:null, funding8h:null, fundingDailyPct:+(b.fundingDailyAbs*100).toFixed(6), action:b.action, capital:P.capitalUSD, borrowed: Math.round(b.notional - P.capitalUSD), notional:b.notional, estDaily:+b.estDaily.toFixed(4), label:'SCANNER', profitable:true, "params.takerFee":P.takerFee, "params.slippage":P.slippage, "params.borrowDaily":P.borrowDaily, "params.targetLTV":P.targetLTV, "params.minProfitDailyPct":P.minProfitDailyPct, krAgeMin: b.krAgeMin, fresh: true, validUntil: b.validUntil, remainMin: b.remainMin }); }

return [{ json: { message: lines.join('\n'), health: healthMsg, healthPrices, rows: allRows, alert } }];"
      },
      "id": "35d9e793-735d-4c33-ac87-5dd8d4c64a9a",
      "name": "Analyze & Advise",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [
        -608,
        496
      ]
    },
    {
      "parameters": {
        "language": "JavaScript",
        "jsCode": "let m=$json.message||'';try{m=String(m).replace(/\u0000/g,'')}catch(_){}if(m.length>3900)m=m.slice(0,3900)+'\n… (truncated)';return[{json:{message:m,messageEnc:encodeURIComponent(m)}}];"
      },
      "id": "8288fb94-226f-41e3-a374-86372179a508",
      "name": "Escape — Report",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [
        -432,
        496
      ]
    },
    {
      "parameters": {
        "language": "JavaScript",
        "jsCode": "let m=$json.health||'';try{m=String(m).replace(/\u0000/g,'')}catch(_){}if(m.length>3900)m=m.slice(0,3900)+'\n… (truncated)';return[{json:{message:m,messageEnc:encodeURIComponent(m)}}];"
      },
      "id": "6ddc3ebf-5ed3-44e5-90cb-e46d4f2ac6ed",
      "name": "Escape — Health",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [
        -432,
        336
      ]
    },
    {
      "parameters": {
        "language": "JavaScript",
        "jsCode": "let m=$json.healthPrices||'';try{m=String(m).replace(/\u0000/g,'')}catch(_){}if(m.length>3900)m=m.slice(0,3900)+'\n… (truncated)';return[{json:{message:m,messageEnc:encodeURIComponent(m)}}];"
      },
      "id": "42d7263d-55b4-4608-9983-518790ed4ff1",
      "name": "Escape — Health Prices",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [
        -432,
        176
      ]
    },
    {
      "parameters": {
        "chatId": "YOUR_CHAT_ID",
        "text": "={{ $json.message }}",
        "additionalFields": {
          "parse_mode": "HTML"
        }
      },
      "id": "926adf65-3195-4ba7-b57f-bd7e7bf5e975",
        "name": "Telegram — Report",
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1,
      "position": [
        -256,
        432
      ],
      "webhookId": "your_webhook_id_here",
      "credentials": {
        "telegramApi": {
          "id": "FJFcsw1TJ4UVNnkg",
          "name": "Telegram account"
        }
      }
    },
    {
      "parameters": {
        "url": "={{ 'https://api.telegram.org/botYOUR_BOT_TOKEN/sendMessage?chat_id=YOUR_CHAT_ID&parse_mode=HTML&text=' + ($json.messageEnc || encodeURIComponent($json.message || '')) }}",
        "options": {
          "timeout": 8000
        }
      },
      "id": "5187a191-28dd-4bca-9afb-e4d85143457a",
      "name": "HTTP Fallback — Report",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        -256,
        560
      ],
      "alwaysOutputData": true,
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "chatId": "YOUR_CHAT_ID",
        "text": "={{ $json.message }}",
        "additionalFields": {
          "parse_mode": "HTML"
        }
      },
      "id": "2c4417cd-16b9-4a27-979c-8018b276f729",
      "name": "Telegram — Health",
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1,
      "position": [
        -256,
        272
      ],
      "webhookId": "your_webhook_id_here",
      "credentials": {
        "telegramApi": {
          "id": "FJFcsw1TJ4UVNnkg",
          "name": "Telegram account"
        }
      }
    },
    {
      "parameters": {
        "url": "={{ 'https://api.telegram.org/botYOUR_BOT_TOKEN/sendMessage?chat_id=YOUR_CHAT_ID&parse_mode=HTML&text=' + ($json.messageEnc || encodeURIComponent($json.message || '')) }}",
        "options": {
          "timeout": 8000
        }
      },
      "id": "7de65f2f-73fd-4a20-a36d-e4373039d4e5",
      "name": "HTTP Fallback — Health",
      "typeVersion": 4,
      "type": "n8n-nodes-base.httpRequest",
      "position": [
        -256,
        176
      ],
      "alwaysOutputData": true,
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "chatId": "YOUR_CHAT_ID",
        "text": "={{ $json.message }}",
        "additionalFields": {
          "parse_mode": "HTML"
        }
      },
      "id": "f4facca9-61de-4787-814f-df9cd0d8dfdd",
      "name": "Telegram — Health Prices",
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1,
      "position": [
        -256,
        112
      ],
      "webhookId": "your_webhook_id_here",
      "credentials": {
        "telegramApi": {
          "id": "FJFcsw1TJ4UVNnkg",
          "name": "Telegram account"
        }
      }
    },
    {
      "parameters": {
        "url": "={{ 'https://api.telegram.org/botYOUR_BOT_TOKEN/sendMessage?chat_id=YOUR_CHAT_ID&parse_mode=HTML&text=' + ($json.messageEnc || encodeURIComponent($json.message || '')) }}",
        "options": {
          "timeout": 8000
        }
      },
      "id": "3a66f175-c11b-4de8-bd8f-ea079c388f8f",
      "name": "HTTP Fallback — Health Prices",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        -256,
        32
      ],
      "alwaysOutputData": true,
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "language": "JavaScript",
        "jsCode": "// Build alert if exists
const a=$json.alert; if(!a) return []; return [{json:{message:a, messageEnc:encodeURIComponent(a)}}];"
      },
      "id": "f0316fbb-c93f-4b3f-b274-d4657ee31e33",
      "name": "Build Alert (if profitable)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [
        -432,
        656
      ]
    },
    {
      "parameters": {
        "chatId": "YOUR_CHAT_ID",
        "text": "={{ $json.message }}",
        "additionalFields": {
          "parse_mode": "HTML"
        }
      },
      "id": "ffe1604c-b83a-43b9-8d20-380dc56ba4eb",
      "name": "Telegram — Alert",
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1,
      "position": [
        -256,
        640
      ],
      "webhookId": "your_webhook_id_here",
      "credentials": {
        "telegramApi": {
          "id": "FJFcsw1TJ4UVNnkg",
          "name": "Telegram account"
        }
      }
    },
    {
      "parameters": {
        "url": "={{ 'https://api.telegram.org/botYOUR_BOT_TOKEN/sendMessage?chat_id=YOUR_CHAT_ID&parse_mode=HTML&text=' + ($json.messageEnc || encodeURIComponent($json.message || '')) }}",
        "options": {
          "timeout": 8000
        }
      },
      "id": "6f9e353d-177d-4c53-98a6-e050d5323dfd",
      "name": "HTTP Fallback — Alert",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        -256,
        736
      ],
      "alwaysOutputData": true,
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "language": "JavaScript",
        "jsCode": "const rows=Array.isArray($json.rows)?$json.rows:[];return rows.map(r=>({json:r}));"
      },
      "id": "a8ee4740-6de8-4e86-a844-92cc479ff200",
      "name": "Rows → Items",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [
        -432,
        -48
      ]
    },
    {
      "parameters": {
        "operation": "append",
        "documentId": {
          "__rl": true,
          "value": "YOUR_SHEET_ID",
          "mode": "id"
        },
        "sheetName": {
          "__rl": true,
          "value": "DSFAB_Logs",
          "mode": "name"
        },
        "columns": {
          "mappingMode": "autoMapInputData",
          "value": {},
          "matchingColumns": [],
          "schema": []
        },
        "options": {}
      },
      "id": "7b5b52ca-3df9-4216-9281-19bb3faa37f4",
      "name": "Google Sheets — Append",
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4,
      "position": [
        -256,
        -96
      ]
    }
  ],
  "connections": {
    "Cron (every 2m)": { "main": [ [ { "node": "Assets Config (20 both-supported)", "type": "main", "index": 0 } ] ] },
    "Assets Config (20 both-supported)": { "main": [ [ { "node": "CB — Fetch Price (per asset)", "type": "main", "index": 0 }, { "node": "KR — Funding (per asset)", "type": "main", "index": 0 } ] ] },
    "CB — Fetch Price (per asset)": { "main": [ [ { "node": "Merge CB (wait)", "type": "main", "index": 0 } ] ] },
    "KR — Funding (per asset)": { "main": [ [ { "node": "Merge KR (wait)", "type": "main", "index": 0 } ] ] },
    "Merge CB (wait)": { "main": [ [ { "node": "Barrier CB+KR", "type": "main", "index": 0 } ] ] },
    "Merge KR (wait)": { "main": [ [ { "node": "Barrier CB+KR", "type": "main", "index": 1 } ] ] },
    "Barrier CB+KR": { "main": [ [ { "node": "Assemble Snapshot", "type": "main", "index": 0 } ] ] },
    "Assemble Snapshot": { "main": [ [ { "node": "Analyze & Advise", "type": "main", "index": 0 } ] ] },
    "Analyze & Advise": { "main": [ [ { "node": "Escape — Report", "type": "main", "index": 0 }, { "node": "Escape — Health", "type": "main", "index": 0 }, { "node": "Escape — Health Prices", "type": "main", "index": 0 }, { "node": "Rows → Items", "type": "main", "index": 0 }, { "node": "Build Alert (if profitable)", "type": "main", "index": 0 } ] ] },
    "Escape — Report": { "main": [ [ { "node": "Telegram — Report", "type": "main", "index": 0 }, { "node": "HTTP Fallback — Report", "type": "main", "index": 0 } ] ] },
    "Escape — Health": { "main": [ [ { "node": "Telegram — Health", "type": "main", "index": 0 }, { "node": "HTTP Fallback — Health", "type": "main", "index": 0 } ] ] },
    "Escape — Health Prices": { "main": [ [ { "node": "Telegram — Health Prices", "type": "main", "index": 0 }, { "node": "HTTP Fallback — Health Prices", "type": "main", "index": 0 } ] ] },
    "Build Alert (if profitable)": { "main": [ [ { "node": "Telegram — Alert", "type": "main", "index": 0 }, { "node": "HTTP Fallback — Alert", "type": "main", "index": 0 } ] ] },
    "Rows → Items": { "main": [ [ { "node": "Google Sheets — Append", "type": "main", "index": 0 } ] ] }
  },
  "active": false,
  "settings": { "executionOrder": "v1" },
  "versionId": "905e04c4-e8ad-486c-bb2d-e78f307eb4f3",
  "meta": { "instanceId": "REDACTED" },
  "id": "ODhH5n2KFhtCIYh2",
  "tags": []
}